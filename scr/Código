import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
import time
import json
import sys
from skimage.feature import graycomatrix, graycoprops
from skimage.measure import shannon_entropy
from skimage.filters import rank
from skimage.morphology import disk
from skimage.util import img_as_ubyte


def calcular_metricas_globais(gray_image):
    entropy = shannon_entropy(gray_image)
    variance = np.var(gray_image)

    glcm = graycomatrix(gray_image, [1], [0], symmetric=True, normed=True)
    homogeneity = graycoprops(glcm, 'homogeneity')[0, 0]

    return {
        "Entropia": entropy,
        "Variância": variance,
        "Homogeneidade": homogeneity
    }

def classificar_complexidade(entropia):
    LIMIAR_ENTROPIA = 6.0
    return "Alta Complexidade" if entropia > LIMIAR_ENTROPIA else "Baixa Complexidade"

def gerar_mapa_convolucao(gray_image):
    kernel_vertical = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    return cv2.filter2D(gray_image, -1, kernel_vertical)

def gerar_mapa_textura(gray_image):
    return rank.entropy(gray_image, disk(10))


def processar_imagem(caminho_imagem):
    try:
        image = cv2.imread(caminho_imagem)
        if image is None:
            raise FileNotFoundError()
    except FileNotFoundError:
        print(f" erro: Não é possível carregar a imagem em: {caminho_imagem} ")
        print(" Verifique se o caminho esta correto e o arquivo existe ")
        return None

    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    nome_arquivo = os.path.basename(caminho_imagem)

    medidas = calcular_metricas_globais(gray_image)
    classificacao = classificar_complexidade(medidas["Entropia"])
    mapa_convolucao = gerar_mapa_convolucao(gray_image)
    mapa_textura = gerar_mapa_textura(gray_image)

    return {
        "nome_arquivo": nome_arquivo,
        "medidas": medidas,
        "classificacao": classificacao,
        "original_gray": gray_image,
        "original_color": image,
        "mapa_conv": mapa_convolucao,
        "mapa_textura": mapa_textura
    }


def gerar_graficos_comparativos(lista_de_resultados):
    if not lista_de_resultados or len(lista_de_resultados) < 2:
        print(" erro: é necessários pelo menos 2 resultados para realizar a comparar.")
        return

    nomes = [r['nome_arquivo'] for r in lista_de_resultados]
    entropias = [r['medidas']['Entropia'] for r in lista_de_resultados]
    variancias = [r['medidas']['Variância'] for r in lista_de_resultados]
    homogeneidades = [r['medidas']['Homogeneidade'] for r in lista_de_resultados]

    fig, axes = plt.subplots(1, 3, figsize=(20, 6))
    fig.suptitle("Gráficos Comparativos (Medidas Globais)", fontsize=16)

    axes[0].bar(nomes, entropias, color='blue')
    axes[0].set_title("Entropia (Aleatoriedade)")
    axes[0].tick_params(axis='x', rotation=45)

    axes[1].bar(nomes, variancias, color='green')
    axes[1].set_title("Variância ")
    axes[1].tick_params(axis='x', rotation=45)

    axes[2].bar(nomes, homogeneidades, color='red')
    axes[2].set_title("Homogeneidade ")
    axes[2].tick_params(axis='x', rotation=45)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()


def analisar_tecido_glcm(imagem_gray):
    print("\n--- Contexto: INSPEÇÃO DE TECIDO  ")

    imagem = cv2.resize(imagem_gray, (300, 300))
    img_cor = cv2.cvtColor(imagem, cv2.COLOR_GRAY2BGR)

    img_borra = cv2.medianBlur(imagem, 21)
    _, mascara = cv2.threshold(img_borra, 80, 255, cv2.THRESH_BINARY_INV)
    contor, _ = cv2.findContours(mascara, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    recorte = imagem[0:50, 0:50]
    com_erro = False

    if contor:
        borda = max(contor, key=cv2.contourArea)
        if cv2.contourArea(borda) > 100:
            com_erro = True
            pos_x, pos_y, larg, altu = cv2.boundingRect(borda)
            larg, altu = max(larg, 40), max(altu, 40)
            recorte = imagem[pos_y:min(pos_y+altu, 299), pos_x:min(pos_x+larg, 299)]
            cv2.rectangle(img_cor, (pos_x, pos_y), (pos_x+larg, pos_y+altu), (0, 0, 255), 2)

    if recorte.size > 0:
        matriz = graycomatrix(recorte, [1], [0], 256, symmetric=True, normed=True)
        energia = graycoprops(matriz, 'energy')[0, 0]
        contraste = graycoprops(matriz, 'contrast')[0, 0]
    else:
        energia, contraste = 0, 0

    res_txt = "DANIFICADO" if com_erro else "INTEIRO"
    cor_txt = 'red' if com_erro else 'green'

    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img_cor, cv2.COLOR_BGR2RGB))
    plt.title(f" Diagnostico: {res_txt}", color=cor_txt, fontweight='bold')
    plt.subplot(1, 2, 2)
    plt.imshow(recorte, cmap='gray')
    plt.title(f"Recorte Analisado \n Energia: {energia:.4f} (homogenidade)\nContraste: {contraste:.1f} (irregularidade)")
    plt.tight_layout()
    plt.show()

def analisar_tumor_assimetria(imagem_gray):


    print("\n--- Contexto: DIAGNÓSTICO DE TUMOR ")

    suave = cv2.GaussianBlur(imagem_gray, (5, 5), 0)

    _, mask_cranio = cv2.threshold(suave, 130, 255, cv2.THRESH_BINARY)
    kernel_cranio = np.ones((3,3), np.uint8)
    mask_cranio = cv2.morphologyEx(mask_cranio, cv2.MORPH_CLOSE, kernel_cranio)
    mask_cranio = cv2.morphologyEx(mask_cranio, cv2.MORPH_OPEN, kernel_cranio)

    _, mask_tumor_bruta = cv2.threshold(suave, 100, 255, cv2.THRESH_BINARY)
    mask_tumor = cv2.subtract(mask_tumor_bruta, mask_cranio) 
    kernel_tumor = np.ones((5,5), np.uint8) 
    mask_tumor = cv2.morphologyEx(mask_tumor, cv2.MORPH_OPEN, kernel_tumor)
    mask_tumor = cv2.morphologyEx(mask_tumor, cv2.MORPH_CLOSE, kernel_tumor)

    _, mask_cerebro_base = cv2.threshold(suave, 30, 255, cv2.THRESH_BINARY)
    mask_cerebro = cv2.subtract(mask_cerebro_base, mask_cranio)
    mask_cerebro = cv2.subtract(mask_cerebro, mask_tumor)

    imagem_bgr_base = cv2.cvtColor(imagem_gray, cv2.COLOR_GRAY2BGR)
    mapa_final = np.zeros_like(imagem_bgr_base)


    heatmap = cv2.applyColorMap(imagem_gray, cv2.COLORMAP_JET)


    mapa_final[mask_cerebro == 255] = heatmap[mask_cerebro == 255]

    mapa_final[mask_tumor == 255] = [0, 0, 255]

    mapa_final[mask_cranio == 255] = [0, 255, 0]

    tumor_encontrado = False
    contornos, _ = cv2.findContours(mask_tumor, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    contornos_validos = [cnt for cnt in contornos if cv2.contourArea(cnt) > 50]

    status_texto = " saudavel / normal "
    cor_titulo = 'green'

    if len(contornos_validos) > 0:
        tumor_encontrado = True
        status_texto = " possivel tumor detectado  "
        cor_titulo = 'red'

        cv2.drawContours(mapa_final, contornos_validos, -1, (0, 255, 255), 2)

        maior_tumor = max(contornos_validos, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(maior_tumor)
        cv2.rectangle(mapa_final, (x, y), (x + w, y + h), (0, 255, 255), 2)


    mapa_final_rgb = cv2.cvtColor(mapa_final, cv2.COLOR_BGR2RGB)
    
    plt.figure(figsize=(10, 8))
    plt.imshow(mapa_final_rgb)
    plt.title(f"Status: {status_texto}\nVerde=Crânio | Vermelho=Tumor | Mapa=Cérebro", 
              color=cor_titulo, fontweight='bold', fontsize=12)
    plt.axis('off')
    plt.show()


def analisar_complexidade_caos(imagem_gray):
    print("\n---- ANÁLISE DE COMPLEXIDADE (entropia x homogenidade) ")

    entropia = shannon_entropy(imagem_gray)
    matriz = graycomatrix(imagem_gray, [1], [0], 256, symmetric=True, normed=True)
    homogen = graycoprops(matriz, 'homogeneity')[0, 0]

    figura, eixos = plt.subplots(1, 3, figsize=(12, 5))
    eixos[0].imshow(imagem_gray, cmap='gray')
    eixos[0].set_title("Imagem")
    eixos[0].axis('off')
    eixos[1].bar(['Entropia'], [entropia], color='salmon')
    eixos[1].set_ylim(0, 8)
    eixos[1].set_title("Caos (0-8)")
    eixos[1].text(0, entropia+0.1, f"{entropia:.2f}", ha='center')
    eixos[2].bar(['Homogeneidade'], [homogen], color='skyblue')
    eixos[2].set_ylim(0, 1)
    eixos[2].set_title("Suavidade (0-1)")
    eixos[2].text(0, homogen+0.02, f"{homogen:.2f}", ha='center')
    plt.tight_layout()
    plt.show()

def calcular_mapa_contraste_local(imagem_gray, N_LEVELS=8, WINDOW_SIZE=15, PASSO=5):

    print("\n--- MAPA DE CONTRASTE LOCAL ")
    print(f"Config: Janela {WINDOW_SIZE}x{WINDOW_SIZE}, Níveis {N_LEVELS}, Passo {PASSO}")
    
    start_time = time.time()

    try:
        image_ubyte = img_as_ubyte(imagem_gray)
        bins = np.linspace(0, 255, N_LEVELS+1)
        image_quantized = np.digitize(image_ubyte, bins) - 1

        image_quantized = np.clip(image_quantized, 0, N_LEVELS-1).astype(int)

        h, w = image_quantized.shape

        h_out = (h - WINDOW_SIZE) // PASSO + 1
        w_out = (w - WINDOW_SIZE) // PASSO + 1
        
        if h_out <= 0 or w_out <= 0:
            print(" erro: Janela maior que a imagem  ")
            return

        contrast_map_small = np.zeros((h_out, w_out), dtype=np.float32)

        print(f" Processando de grade reduzida:  {w_out}x{h_out} pixels ")

        idx_i = 0
        for i in range(0, h - WINDOW_SIZE + 1, PASSO):
            idx_j = 0
            for j in range(0, w - WINDOW_SIZE + 1, PASSO):

                window = image_quantized[i : i + WINDOW_SIZE, j : j + WINDOW_SIZE]
                
                glcm = graycomatrix(window, [1], [0], levels=N_LEVELS, symmetric=True, normed=True)
                contrast = graycoprops(glcm, 'contrast')[0, 0]
                
                contrast_map_small[idx_i, idx_j] = contrast
                idx_j += 1
            idx_i += 1

        contrast_map_full = cv2.resize(contrast_map_small, (w, h), interpolation=cv2.INTER_LINEAR)

        if contrast_map_full.max() > 0:
            contrast_map_full = contrast_map_full / contrast_map_full.max()

        end_time = time.time()
        print(f" Cálculo concluído em {end_time - start_time:.2f} segundos.")

        fig, axes = plt.subplots(1, 2, figsize=(12, 6))
        axes[0].imshow(imagem_gray, cmap='gray')
        axes[0].set_title('Imagem Original')
        axes[0].axis('off')
        
        im = axes[1].imshow(contrast_map_full, cmap='jet')
        axes[1].set_title(f' Contraste Local (Passo={PASSO})')
        axes[1].axis('off')
        fig.colorbar(im, ax=axes[1], shrink=0.8)
        plt.tight_layout()
        plt.show()

    except Exception as e:
        print(f" Erro durante o calculo do mapa de contraste : {e}")

def exibir_mapa(mapa, titulo, cmap='gray'):
    plt.figure(figsize=(8, 6))
    plt.imshow(mapa, cmap=cmap)
    plt.title(titulo)
    plt.axis('off')
    plt.show()

def converter_hsv(img_color):
    return cv2.cvtColor(img_color, cv2.COLOR_BGR2HSV)

def equalizar_histograma(img_gray):
    eq = cv2.equalizeHist(img_gray)
    hist_eq = cv2.calcHist([eq], [0], None, [256], [0,256])

    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(eq, cmap='gray')
    plt.title(" Imagem Equalizada")
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.plot(hist_eq, color='gray')
    plt.title(" Histograma Equalizado")
    plt.show()
    return eq

def binarizar_imagem(img_gray, limiar=127):
    _, bw = cv2.threshold(img_gray, limiar, 255, cv2.THRESH_BINARY)
    exibir_mapa(bw, f"Imagem Binarizada (Limiar={limiar})")
    return bw

def detectar_bordas(img_gray):
    bordas = cv2.Canny(img_gray, 100, 200)
    exibir_mapa(bordas, "Bordas (Canny)")
    return bordas

def detectar_formas_geometricas(img_color):
    json_path = "forms.json"
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            formas_dict = json.load(f)
    except FileNotFoundError:
        print(f" Erro: arquivo 'forms.json' não encontrado.")
        print(" crie ele  no mesmo diretório do script com o conteúdo:")
        print('{"3":"Triangulo", "4":"Quadrilatero", "5":"pentagono"}')
        return []

    gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
    bordas = cv2.Canny(gray, 80, 200)
    contornos, _ = cv2.findContours(bordas, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    img_saida = img_color.copy()
    formas_encontradas = []

    for c in contornos:
        if cv2.contourArea(c) < 200: continue
        per = cv2.arcLength(c, True)
        aprox = cv2.approxPolyDP(c, 0.04 * per, True)
        lados = len(aprox)
        nome = formas_dict.get(str(lados), f"{lados} lados")

        M = cv2.moments(c)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])
            cv2.putText(img_saida, nome, (cx - 40, cy), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

        cv2.drawContours(img_saida, [aprox], -1, (0, 255, 0), 2)
        formas_encontradas.append({"forma": nome, "lados": lados})

    exibir_mapa(cv2.cvtColor(img_saida, cv2.COLOR_BGR2RGB), "Formas Detectadas")
    print(f"Formas detectadas: {formas_encontradas}")
    return formas_encontradas

def gerar_relatorio(resultados, caminho_relatorio="relatorio.txt"):
    try:
        with open(caminho_relatorio, "w") as f:
            f.write(" Relatorio de analise da imagem \n")
            f.write(f" Arquivo : {resultados['nome_arquivo']}\n")
            f.write(f" Dimensões : {resultados['original_color'].shape[1]}x{resultados['original_color'].shape[0]}\n")
            f.write("\n--- Métricas Globais ---\n")
            for chave, valor in resultados['medidas'].items():
                f.write(f"{chave}: {valor:.4f}\n")
            f.write(f"\nClassificação: {resultados['classificacao']}\n")
        print(f"Relatório salvo com sucesso em: {caminho_relatorio}")
    except Exception as e:
        print(f"Erro ao gerar relatório: {e}")



def main():

    resultados_principal = None

    while True:
        nome_arquivo = resultados_principal['nome_arquivo'] if resultados_principal else None

        print("\n SISTEMA INTEGRADO DE VISÃO COMPUTACIONAL  ")
        if nome_arquivo:
            print(f"Imagem Carregada: {nome_arquivo} ")
        else:
            print("Nenhuma imagem carregada. Comece pela Opção 1. ")

        print("-------------------- --------------------------------- ")
        print(" 1. Carregar/Processar Nova Imagem Principal ")
        print(" 2. Converter para escala de cinza ")
        print(" 3. Converter para HSV ")
        print(" 4. Equalizar histograma ")
        print(" 5. Binarizar imagem ")
        print(" 6. Detectar bordas ")
        print(" 7. Calcular métricas Globais ")
        print(" 8. Análise de Complexidade  ")
        print(" 9. Exibir Mapa de Padrões com convolução ")
        print(" 10. Exibir Mapa de Textura Densa ")
        print(" 11. Comparar com metricas globais de segunda imagem ")
        print(" 12. Análise de Tecido  ")
        print(" 13. Análise de Tumor  ")
        print(" 14. Análise de Complexidade entropia x homogenidade ")
        print(" 15. Mapa de contraste local  ")
        print(" 16. Gerar relatório em txt   ")
        print(" 0. Sair   ")
        print("---------------------------------------------- ------")
 
        escolha = input("\nEscolha uma opção: ")

        if escolha == '1':
            caminho_principal_input = input("Cole o caminho da imagem principal:  ").strip().strip("'\"")
            resultados_principal = processar_imagem(caminho_principal_input)
            if resultados_principal:
                print("\n--- Imagem Carregada e processada ")
            else:
                resultados_principal = None
            continue

        elif escolha == '0':
            print("Saindo...")
            break

        if not resultados_principal:
            print("\nErro: Nenhuma imagem carregada, Use a Opção 1 primeiro.")
            time.sleep(1)
            continue

        if escolha == '2':
            exibir_mapa(resultados_principal['original_gray'], "Imagem em Escala de Cinza")

        elif escolha == '3':
            hsv = converter_hsv(resultados_principal['original_color'])
            exibir_mapa(cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB), "Imagem em HSV")

        elif escolha == '4':
            equalizar_histograma(resultados_principal['original_gray'])

        elif escolha == '5':
            binarizar_imagem(resultados_principal['original_gray'])

        elif escolha == '6':
            detectar_bordas(resultados_principal['original_gray'])

        elif escolha == '7':
            print("\n--- [Métricas Globais] ---")
            for chave, valor in resultados_principal['medidas'].items():
                print(f" > {chave}: {valor:.4f}")

        elif escolha == '8':
            print("\n--- [Classificação de Complexidade] ---")
            print(f" > {resultados_principal['classificacao']}")

        elif escolha == '9':
            exibir_mapa(resultados_principal['mapa_conv'], "Mapa de Padrões com convolução )", cmap='gray')

        elif escolha == '10':
            exibir_mapa(resultados_principal['mapa_textura'], "Mapa de Textura Densa (Entropia Local)", cmap='plasma')

        elif escolha == '11':
            print("\n--- [Comparação] ---")
            caminho_secundaria_input = input("Cole o CAMINHO da SEGUNDA imagem: ").strip().strip("'\"")
            resultados_secundaria = processar_imagem(caminho_secundaria_input)
            if resultados_secundaria:
                print("Processando comparação e gerando gráfico...")
                gerar_graficos_comparativos([resultados_principal, resultados_secundaria])
            else:
                print("Falha ao processar a segunda imagem.")

        elif escolha == '12':
            analisar_tecido_glcm(resultados_principal['original_gray'])

        elif escolha == '13':
            analisar_tumor_assimetria(resultados_principal['original_gray'])

        elif escolha == '14':
            analisar_complexidade_caos(resultados_principal['original_gray'])

        elif escolha == '15':
            calcular_mapa_contraste_local(resultados_principal['original_gray'])

        elif escolha == '16':
            gerar_relatorio(resultados_principal)

        else:
            print("Opção inválida. Tente novamente.")

        time.sleep(1)

if __name__ == "__main__":
    main()
